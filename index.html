<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Radial Clock Slider Paints The Sky</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background: black;
      color: white;
      font-family: sans-serif;
    }

    .radial-slider {
      position: relative;
      width: 300px;
      height: 300px;
      border-radius: 50%;
      border: 2px solid #555;
    }

    .handle {
      position: absolute;
      width: 60px;
      height: 60px;
      background: rgb(255, 242, 0);
      border-radius: 50%;
      top: 0;
      left: 50%;
      transform: translate(-50%, -50%);
      cursor: pointer;
      border: 2px solid #555;
    }

    .info {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      font-size: 40px;
      line-height: 1.4;
    }

    html, body {
      overflow: hidden;
    }
  </style>
</head>

<body>

  <div class="radial-slider" id="slider">
    <div class="handle" id="handle"></div>
    <div class="info" id="info"></div>
  </div>

  <script>
function divisions() {
    const base = 100/31
    let curr = 0

    let percents = []
    for (let index = 0; index < 31; index++) {
        curr+=base
        percents.push(curr.toFixed(2))
    }
    return [0, ...percents]
}
  const divs = divisions()
    let baselineGradients = []
    async function loadGradients() {
      const res = await fetch("gradients.bin");
      const buf = await res.arrayBuffer();
      console.log('gradients loaded')
      const data = new Uint8Array(buf);

      const width = 32;
      const height = 1440;
      const gradients = [];
      let i = 0;

      for (let y = 0; y < height; y++) {
        const row = [];
        for (let x = 0; x < width; x++) {
          row.push([data[i++], data[i++], data[i++]]);
        }
        gradients.push(row);
      }

      return gradients
    }

    function colorsToGradient(colors, divs) {
        const s = `linear-gradient(to bottom,`
        const m = colors.map((color, index) => {
            return ` rgb(${color}) ${parseFloat(divs[index])}%`
        }).join(',')
        const e = ')'
        return s+m+e;
    }

    function remapDay(templateImages, anchors, tzOffsetMinutes) {
      if (templateImages.length === 0) {
        throw new Error("Empty images");
      }

      function toMinutes(iso) {
        const d = new Date(iso);
        const mins = d.getUTCHours() * 60 + d.getUTCMinutes();
        return (mins + tzOffsetMinutes + 1440) % 1440;
      }

      const astroBegin = toMinutes(anchors.astronomical_twilight_begin);
      const nautBegin = toMinutes(anchors.nautical_twilight_begin);
      const civilBegin = toMinutes(anchors.civil_twilight_begin);
      const sunrise = toMinutes(anchors.sunrise);
      const noon = toMinutes(anchors.solar_noon);
      const sunset = toMinutes(anchors.sunset);
      const civilEnd = toMinutes(anchors.civil_twilight_end);
      const nautEnd = toMinutes(anchors.nautical_twilight_end);
      const astroEnd = toMinutes(anchors.astronomical_twilight_end);

      const newSegments = [
        [0, astroBegin],
        [astroBegin, nautBegin],
        [nautBegin, civilBegin],
        [civilBegin, sunrise],
        [sunrise, noon],
        [noon, sunset],
        [sunset, civilEnd],
        [civilEnd, nautEnd],
        [nautEnd, astroEnd],
        [astroEnd, 1440]
      ];

      const templateAnchors = {
        astronomical_twilight_begin: "2024-06-16T01:48:31Z",
        nautical_twilight_begin: "2024-06-16T02:31:17Z",
        civil_twilight_begin: "2024-06-16T03:10:13Z",
        sunrise: "2024-06-16T03:40:18Z",
        solar_noon: "2024-06-16T10:42:24Z",
        sunset: "2024-06-16T17:44:30Z",
        civil_twilight_end: "2024-06-16T18:14:35Z",
        nautical_twilight_end: "2024-06-16T18:53:31Z",
        astronomical_twilight_end: "2024-06-16T19:36:18Z"
      };

      const tplAstroBegin = toMinutes(templateAnchors.astronomical_twilight_begin);
      const tplNautBegin = toMinutes(templateAnchors.nautical_twilight_begin);
      const tplCivilBegin = toMinutes(templateAnchors.civil_twilight_begin);
      const tplSunrise = toMinutes(templateAnchors.sunrise);
      const tplNoon = toMinutes(templateAnchors.solar_noon);
      const tplSunset = toMinutes(templateAnchors.sunset);
      const tplCivilEnd = toMinutes(templateAnchors.civil_twilight_end);
      const tplNautEnd = toMinutes(templateAnchors.nautical_twilight_end);
      const tplAstroEnd = toMinutes(templateAnchors.astronomical_twilight_end);

      const templateSegments = [
        [0, tplAstroBegin],
        [tplAstroBegin, tplNautBegin],
        [tplNautBegin, tplCivilBegin],
        [tplCivilBegin, tplSunrise],
        [tplSunrise, tplNoon],
        [tplNoon, tplSunset],
        [tplSunset, tplCivilEnd],
        [tplCivilEnd, tplNautEnd],
        [tplNautEnd, tplAstroEnd],
        [tplAstroEnd, 1440]
      ];

      function mapMinute(min) {
        for (let i = 0; i < newSegments.length; i++) {
          const [start, end] = newSegments[i];
          if (min >= start && min < end) {
            const ratio = (min - start) / (end - start || 1);
            const [tplStart, tplEnd] = templateSegments[i];
            return Math.floor(tplStart + ratio * (tplEnd - tplStart));
          }
        }
        return min;
      }

      return Array.from({ length: 1440 }, (_, m) => {
        const tplMinute = mapMinute(m);
        return templateImages[tplMinute];
      }).filter(Boolean);
    }
    let sunriseMinutes = 340
    let sunsetMinutes = 1184
    let gradients = []

    loadGradients().then(gs => {
      baselineGradients = gs.map(g => colorsToGradient(g, divs))
    })
    fetch("https://ipapi.co/json/")
      .then(res => res.json())
      .then(({ latitude, longitude }) => fetch(
        `https://api.sunrise-sunset.org/json?lat=${latitude}&lng=${longitude}&date=today&formatted=0`
      ))
      .then(res => res.json())
      .then(data => {
        console.log('sunrise-sunset loaded')
        const sunriseDate = new Date(data.results.sunrise);
        const sunsetDate = new Date(data.results.sunset);

        sunriseMinutes = sunriseDate.getHours() * 60 + sunriseDate.getMinutes();
        sunsetMinutes = sunsetDate.getHours() * 60 + sunsetDate.getMinutes();
        gradients = remapDay(baselineGradients, data.results, 0)

        const startDrag = (e) => {
          const point = e.touches ? e.touches[0] : e;
          onMouseDown(point);
        };

        slider.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);

        slider.addEventListener('touchstart', startDrag);
        handle.addEventListener('touchstart', startDrag);

        window.addEventListener('touchmove', e => {
          if (e.touches.length > 0) {
            onMouseMove(e.touches[0]);
          }
        }, {passive: true});
        window.addEventListener('touchend', onMouseUp);

        updateHandle();
      })
    const slider = document.getElementById('slider');
    const handle = document.getElementById('handle');
    const info = document.getElementById('info');

    const maxSteps = 1440;
    const stepsPerRotation = 720;
    const degreePerStep = 360 / stepsPerRotation;

    function findCurrentStep() {
      const now = new Date()
      const minutes = Math.floor(now.getHours() * 60 + now.getMinutes())
      return minutes;
    }
    let currentStep = findCurrentStep();
    let isDragging = false;
    let lastAngle = 0;

    function getAngleFromCenter(x, y) {
      const rect = slider.getBoundingClientRect();
      const cx = rect.left + rect.width / 2;
      const cy = rect.top + rect.height / 2;
      const dx = x - cx;
      const dy = y - cy;
      let angle = Math.atan2(dy, dx) * (180 / Math.PI);
      angle = (angle + 90 + 360) % 360;
      return angle;
    }

    function mod(n, m) {
      return ((n % m) + m) % m;
    }

    function onMouseDown(e) {
      if ("preventDefault" in e) {
        e.preventDefault();
      }
      isDragging = true;
      lastAngle = getAngleFromCenter(e.clientX, e.clientY);
    }

    function onMouseMove(e) {
      if (!isDragging) return;

      const angle = getAngleFromCenter(e.clientX, e.clientY);
      let angleDiff = angle - lastAngle;

      if (angleDiff > 180) angleDiff -= 360;
      if (angleDiff < -180) angleDiff += 360;

      let stepDiff = Math.round(angleDiff / degreePerStep);
      currentStep += stepDiff;

      currentStep = mod(currentStep, maxSteps + 1);

      lastAngle = angle;
      updateHandle();
    }

    function onMouseUp() {
      isDragging = false;
    }

    function formatTime(step) {
      const totalMinutes = step % 1440;
      const hours = Math.floor(totalMinutes / 60);
      const minutes = totalMinutes % 60;
      const hh = String(hours).padStart(2, '0');
      const mm = String(minutes).padStart(2, '0');
      return `${hh}:${mm}`;
    }

    function updateHandle() {
      const angle = (currentStep * degreePerStep) % 360;
      const radius = slider.offsetWidth / 2;
      const rad = (angle - 90) * (Math.PI / 180);
      const x = radius + radius * Math.cos(rad);
      const y = radius + radius * Math.sin(rad);

      handle.style.left = `${x}px`;
      handle.style.top = `${y}px`;

      const timeStr = formatTime(currentStep);
      info.innerHTML = timeStr;
      setTheme()
      updateFromIndex()
    }

    function setTheme() {
      if (currentStep > sunriseMinutes && currentStep < sunsetMinutes) {
        slider.style.background = 'white'
        slider.style.color = 'black'
      }
      else {
        slider.style.background = 'black'
        slider.style.color = 'white'
      }
    }

    function updateFromIndex() {
      document.body.style.background = gradients[(currentStep + 1) % 1440];
    }
  </script>
</body>
</html>
